<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini-Photoshop ‚Äî single-file</title>
  <style>
    :root{
      --bg:#0f1724; --panel:#0b1220; --muted:#9ca3af; --accent:#06b6d4; --card:#0b1220;
      --toolbar-w:72px; --toolbar-w-sm:56px;
    }
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;color:#e6eef6;background:linear-gradient(180deg,#061026 0%, #071425 100%);}    
    .app{display:flex;flex-direction:row;height:100vh;gap:12px;padding:12px;box-sizing:border-box}
    /* Responsive: on small screens, toolbar becomes top row */
    @media (max-width:900px){.app{flex-direction:column;padding:8px}}

    /* Left toolbar */
    .toolbar{width:var(--toolbar-w);background:rgba(255,255,255,0.02);border-radius:12px;padding:8px;display:flex;flex-direction:column;gap:8px;align-items:center}
    @media (max-width:900px){.toolbar{width:100%;height:56px;flex-direction:row;justify-content:flex-start;padding:6px;overflow:auto}}
    .tool{width:48px;height:48px;border-radius:8px;display:flex;align-items:center;justify-content:center;cursor:pointer;color:var(--muted);background:transparent;border:1px solid transparent}
    .tool:hover{color:var(--accent);background:rgba(255,255,255,0.02);border-color:rgba(255,255,255,0.03)}
    .tool.active{color:#001217;background:linear-gradient(180deg,var(--accent),#06a7b8);box-shadow:0 6px 18px rgba(6,182,212,0.12)}

    /* Right panels */
    .panels{width:320px;min-width:240px;background:rgba(255,255,255,0.02);border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:12px}
    @media (max-width:900px){.panels{width:100%;display:flex;flex-direction:row;gap:8px;overflow:auto;padding:8px}}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:10px;border-radius:10px}
    .panel h3{margin:0 0 8px 0;font-size:13px;color:var(--muted)}

    /* Center canvas area */
    .canvas-wrap{flex:1;display:flex;flex-direction:column;gap:8px}
    .stage{flex:1;background:linear-gradient(180deg,#071427 0%, #051020 100%);border-radius:12px;display:flex;align-items:center;justify-content:center;padding:12px}
    .editor{position:relative;width:100%;height:100%;max-height:calc(100vh - 160px);border-radius:10px;overflow:hidden;background:repeating-conic-gradient(#dde9f1 0% 5%, transparent 0% 10%);display:flex;align-items:center;justify-content:center}
    .view{position:relative;width:100%;height:100%;display:flex;align-items:center;justify-content:center}
    .controls{display:flex;gap:8px;align-items:center}

    /* stacked canvases */
    .layer-stack{position:relative;touch-action:none}
    canvas.layer{position:absolute;left:0;top:0;width:100%;height:100%;background:transparent}

    /* bottom mini toolbar */
    .bottombar{display:flex;gap:8px;align-items:center;justify-content:space-between;padding:8px}
    .btn{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
    .btn:hover{color:var(--accent)}

    /* layer list */
    .layer-list{display:flex;flex-direction:column;gap:8px}
    .layer-item{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,0.01);padding:6px;border-radius:8px}
    .layer-item .name{flex:1;font-size:13px;color:var(--muted);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .small{font-size:12px;color:var(--muted)}

    input[type=range]{-webkit-appearance:none;background:transparent;width:100%}
    input[type=range]::-webkit-slider-runnable-track{height:6px;background:rgba(255,255,255,0.06);border-radius:6px}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:50%;background:var(--accent);margin-top:-4px}

    /* tool icons are simple SVG-like text */
    .icon{width:20px;height:20px;display:inline-block}
    .muted{color:var(--muted)}

    /* responsive canvas sizing */
    .canvas-container{width:100%;height:calc(100vh - 220px);max-height:calc(100vh - 220px)}
    @media (max-width:900px){.canvas-container{height:56vh;max-height:56vh}}

    /* file input hidden */
    input[type=file]{display:none}

  </style>
</head>
<body>
  <div class="app">
    <div class="toolbar" id="toolbar">
      <div class="tool active" data-tool="brush" title="Brush">üñåÔ∏è</div>
      <div class="tool" data-tool="eraser" title="Eraser">ü©π</div>
      <div class="tool" data-tool="fill" title="Fill (Flood)">ü™£</div>
      <div class="tool" data-tool="rect" title="Rectangle">‚ñ≠</div>
      <div class="tool" data-tool="ellipse" title="Ellipse">‚óØ</div>
      <div class="tool" data-tool="line" title="Line">/</div>
      <div class="tool" data-tool="text" title="Text">T</div>
      <div class="tool" data-tool="move" title="Move">‚ú•</div>
      <div class="tool" data-tool="crop" title="Crop">‚úÇÔ∏è</div>
      <div class="tool" data-tool="select" title="Select (marquee)">‚ñß</div>
      <div class="tool" data-tool="colorpicker" title="Color Picker">üéØ</div>
      <div class="tool" data-tool="pan" title="Pan (space+drag)">ü§ö</div>
    </div>

    <div class="canvas-wrap">
      <div class="stage">
        <div class="editor">
          <div class="view" id="view">
            <div class="canvas-container" id="canvasContainer">
              <div class="layer-stack" id="layerStack" style="width:100%;height:100%">
                <!-- canvases created by JS -->
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="bottombar">
        <div style="display:flex;gap:8px;align-items:center">
          <label class="small">Color</label>
          <input type="color" id="color" value="#0db9c9">
          <label class="small">Size</label>
          <input id="size" type="range" min="1" max="120" value="18">
          <label class="small">Opacity</label>
          <input id="opacity" type="range" min="0" max="100" value="100">
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <button class="btn" id="undoBtn">Undo</button>
          <button class="btn" id="redoBtn">Redo</button>
          <button class="btn" id="addLayerBtn">+ Layer</button>
          <button class="btn" id="importBtn">Import</button>
          <input type="file" id="fileInput" accept="image/*">
          <button class="btn" id="exportBtn">Export</button>
        </div>
      </div>
    </div>

    <div class="panels">
      <div class="panel">
        <h3>Layers</h3>
        <div class="layer-list" id="layerList"></div>
      </div>
      <div class="panel">
        <h3>Tool Options</h3>
        <div id="toolOptions" class="small muted">Select a tool to see options.</div>
      </div>
    </div>
  </div>

<script>
(function(){
  // Basic single-file mini-photoshop.
  // Fixes applied: touch event handlers were previously passing Touch objects (which lack preventDefault)
  // into the same handlers used for MouseEvents. That caused e.preventDefault() to throw.
  // Changes below ensure the original Event is passed to begin/move/up and getPointerEvent extracts the proper touch/mouse point.
  // Also added a small updateFromInputs() helper to avoid undefined-call from colorpicker.

  const toolbar = document.getElementById('toolbar');
  const tools = toolbar.querySelectorAll('.tool');
  const layerStack = document.getElementById('layerStack');
  const layerList = document.getElementById('layerList');
  const colorInput = document.getElementById('color');
  const sizeRange = document.getElementById('size');
  const opacityRange = document.getElementById('opacity');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const addLayerBtn = document.getElementById('addLayerBtn');
  const fileInput = document.getElementById('fileInput');
  const importBtn = document.getElementById('importBtn');
  const exportBtn = document.getElementById('exportBtn');
  const toolOptions = document.getElementById('toolOptions');
  const canvasContainer = document.getElementById('canvasContainer');

  let state = {
    activeTool: 'brush',
    color: '#0db9c9',
    size: 18,
    opacity: 1,
    scale: 1,
    pan: {x:0,y:0},
    isPanning:false,
    selection: null,
  };

  let layers = []; // {id,canvas,ctx,visible,name,history,historyIndex}
  let currentLayerId = null;

  function uid(prefix='l'){
    return prefix + Math.random().toString(36).slice(2,9);
  }

  function resizeAll(w = canvasContainer.clientWidth, h = canvasContainer.clientHeight){
    layers.forEach(l=>{
      // preserve content: draw to temp and scale to new canvas size
      const tmp = document.createElement('canvas'); tmp.width = l.canvas.width; tmp.height = l.canvas.height;
      tmp.getContext('2d').drawImage(l.canvas,0,0);
      l.canvas.width = w; l.canvas.height = h;
      l.ctx.drawImage(tmp,0,0,w,h);
    });
  }

  // create initial base layer
  function createLayer(name = 'Layer'){
    const id = uid();
    const c = document.createElement('canvas');
    c.className = 'layer';
    c.width = canvasContainer.clientWidth || 1024;
    c.height = canvasContainer.clientHeight || 600;
    c.style.zIndex = layers.length;
    c.style.pointerEvents = 'auto';
    c.style.touchAction = 'none';
    const ctx = c.getContext('2d');
    // composition default
    ctx.lineCap = ctx.lineJoin = 'round';

    layerStack.appendChild(c);
    const layerObj = {id,canvas:c,ctx,visible:true,name: name + ' ' + (layers.length+1),history:[],historyIndex:-1};
    layers.push(layerObj);
    currentLayerId = id;
    refreshLayerList();
    attachCanvasEvents(c, layerObj);
    snapshot(layerObj);
    return layerObj;
  }

  function getLayerById(id){return layers.find(l=>l.id===id)}

  function refreshLayerList(){
    layerList.innerHTML='';
    // show in reverse (top first)
    [...layers].reverse().forEach(l=>{
      const item = document.createElement('div'); item.className='layer-item';
      const eye = document.createElement('button'); eye.className='btn'; eye.textContent = l.visible? 'üëÅÔ∏è':'üö´'; eye.title='Toggle visibility';
      eye.onclick = ()=>{ l.visible=!l.visible; l.canvas.style.display = l.visible? 'block':'none'; refreshLayerList(); }
      const name = document.createElement('div'); name.className='name'; name.textContent=l.name;
      name.onclick = ()=>{ currentLayerId = l.id; refreshLayerList(); }
      if(l.id===currentLayerId){ name.style.color='white'; item.style.boxShadow='inset 0 0 0 1px rgba(255,255,255,0.02)'; }

      const del = document.createElement('button'); del.className='btn'; del.textContent='üóëÔ∏è'; del.title='Delete';
      del.onclick = ()=>{ if(layers.length===1){ alert('Need at least one layer'); return;} removeLayer(l.id); }

      item.appendChild(eye); item.appendChild(name); item.appendChild(del);
      layerList.appendChild(item);
    });
  }

  function removeLayer(id){
    const idx = layers.findIndex(l=>l.id===id);
    if(idx>=0){
      const l = layers[idx]; layerStack.removeChild(l.canvas); layers.splice(idx,1);
      if(currentLayerId===id) currentLayerId = layers[layers.length-1].id;
      refreshLayerList();
    }
  }

  // tool activation
  toolbar.addEventListener('click',(e)=>{
    const t = e.target.closest('.tool'); if(!t) return;
    tools.forEach(x=>x.classList.remove('active'));
    t.classList.add('active');
    state.activeTool = t.dataset.tool;
    updateToolOptions();
  });

  function updateToolOptions(){
    const tool = state.activeTool;
    let html = '';
    if(tool==='brush' || tool==='eraser'){
      html = `<div class='small'>Brush: <b>${tool}</b></div>`;
      html += `<div class='small'>Size: <span id='optSize'>${state.size}</span></div>`;
    } else if(tool==='text') html = `<div class='small'>Click to place text. Use Enter to finish.</div>`;
    else if(tool==='fill') html = `<div class='small'>Flood fill current layer with selected color (touch-friendly)</div>`;
    else html = `<div class='small'>Tool: <b>${tool}</b></div>`;
    toolOptions.innerHTML = html;
  }

  // small helper used by colorpicker to sync small UI bits
  function updateFromInputs(){
    try{
      colorInput.value = state.color;
      sizeRange.value = state.size;
      const el = document.getElementById('optSize'); if(el) el.textContent = state.size;
    }catch(e){/* ignore */}
  }

  // snapshot for undo
  function snapshot(layerObj){
    try{
      const data = layerObj.ctx.getImageData(0,0,layerObj.canvas.width,layerObj.canvas.height);
      // truncate future
      layerObj.history.splice(layerObj.historyIndex+1);
      layerObj.history.push(data);
      layerObj.historyIndex = layerObj.history.length-1;
      // limit
      if(layerObj.history.length>40){ layerObj.history.shift(); layerObj.historyIndex--; }
      updateUndoButtons();
    }catch(e){console.warn('snapshot failed',e)}
  }
  function undo(){ const l = getLayerById(currentLayerId); if(!l) return; if(l.historyIndex>0){ l.historyIndex--; l.ctx.putImageData(l.history[l.historyIndex],0,0); updateUndoButtons(); }}
  function redo(){ const l = getLayerById(currentLayerId); if(!l) return; if(l.historyIndex < l.history.length-1){ l.historyIndex++; l.ctx.putImageData(l.history[l.historyIndex],0,0); updateUndoButtons(); }}
  function updateUndoButtons(){ const l = getLayerById(currentLayerId); undoBtn.disabled = !(l && l.historyIndex>0); redoBtn.disabled = !(l && l.historyIndex<l.history.length-1); }

  undoBtn.addEventListener('click', undo);
  redoBtn.addEventListener('click', redo);
  addLayerBtn.addEventListener('click', ()=>{ createLayer('Layer'); resizeZ(); snapshot(getLayerById(currentLayerId)); });

  importBtn.addEventListener('click', ()=> fileInput.click());
  fileInput.addEventListener('change', (e)=>{
    const f = e.target.files[0]; if(!f) return; const img = new Image(); img.onload = ()=>{
      const l = getLayerById(currentLayerId); l.ctx.clearRect(0,0,l.canvas.width,l.canvas.height); l.ctx.drawImage(img,0,0,l.canvas.width,l.canvas.height); snapshot(l);
    }; img.src = URL.createObjectURL(f);
  });

  exportBtn.addEventListener('click', ()=>{
    // flatten
    const out = document.createElement('canvas'); out.width = layers[0].canvas.width; out.height = layers[0].canvas.height; const octx = out.getContext('2d');
    layers.forEach(l=>{ if(l.visible) octx.drawImage(l.canvas,0,0); });
    out.toBlob(b=>{ const url = URL.createObjectURL(b); const a = document.createElement('a'); a.href=url; a.download='mini-ps.png'; a.click(); URL.revokeObjectURL(url); },'image/png');
  });

  // architecture: each canvas has its own events. we implement drawing tools unified.
  function attachCanvasEvents(canvasEl, layerObj){
    let drawing=false, last=null, start=null;

    function pointerPos(e){
      const rect = canvasEl.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvasEl.width / rect.width);
      const y = (e.clientY - rect.top) * (canvasEl.height / rect.height);
      return {x,y};
    }

    function begin(e){
      // e is the original Event (MouseEvent / TouchEvent)
      if(currentLayerId !== layerObj.id) return; // only active layer accepts drawing
      const ev = getPointerEvent(e);
      if(!ev) return;
      drawing = true; last = pointerPos(ev); start = last;
      const tool = state.activeTool;
      if(tool==='fill'){ floodFill(layerObj, last.x|0, last.y|0, hexToRgba(state.color, Math.round(state.opacity*255))); snapshot(layerObj); drawing=false; }
      else if(tool==='text'){
        const text = prompt('Enter text:'); if(text){ layerObj.ctx.save(); layerObj.ctx.fillStyle = state.color; layerObj.ctx.font = `${Math.max(12, state.size)}px sans-serif`; layerObj.ctx.fillText(text, last.x, last.y); layerObj.ctx.restore(); snapshot(layerObj);} drawing=false; }
      else if(tool==='crop'){
        // simple cropping: define rect and on end crop current layer and all layers to that rect
      }
      else if(tool==='colorpicker'){
        try{
          const px = layerObj.ctx.getImageData(last.x,last.y,1,1).data; const hex = rgbaToHex(px[0],px[1],px[2],px[3]); colorInput.value = hex; state.color = hex; updateFromInputs();
        }catch(e){console.warn('colorpicker failed',e)}
        drawing=false;
      }
      else if(tool==='move'){
        // not implemented complex move of layer content; do simple drag
        layerObj._moveStart = {x: last.x, y: last.y};
      }
      else{
        // brush/eraser/shape start: we'll just record start and maybe draw immediate dot
        drawStroke(layerObj, last, last);
      }
      // prevent default on the original event so scrolling / selection doesn't happen
      if(typeof e.preventDefault === 'function') e.preventDefault();
    }

    function move(e){
      // e is original Event
      if(!drawing) return; const ev = getPointerEvent(e); if(!ev) return; const pos = pointerPos(ev);
      const tool = state.activeTool;
      if(tool==='brush' || tool==='eraser'){
        drawStroke(layerObj, last, pos);
        last = pos;
      } else if(['rect','ellipse','line'].includes(tool)){
        // live-preview: we use an overlay temporary canvas (on top of current) - here we simply redraw the current canvas from history and draw shape
        // Simple approach: clear a temp overlay canvas if exists (create per layer temp)
        drawPreviewShape(layerObj, start, pos, tool);
      } else if(tool==='move'){
        const dx = pos.x - layerObj._moveStart.x; const dy = pos.y - layerObj._moveStart.y; // translate content
        // copy to temp
        const tmp = document.createElement('canvas'); tmp.width = layerObj.canvas.width; tmp.height = layerObj.canvas.height;
        tmp.getContext('2d').drawImage(layerObj.canvas,0,0);
        layerObj.ctx.clearRect(0,0,layerObj.canvas.width,layerObj.canvas.height);
        layerObj.ctx.setTransform(1,0,0,1,dx,dy);
        layerObj.ctx.drawImage(tmp,0,0);
        layerObj.ctx.setTransform(1,0,0,1,0,0);
      }
      if(typeof e.preventDefault === 'function') e.preventDefault();
    }

    function up(e){
      if(!drawing) return; drawing=false; const ev = getPointerEvent(e); if(!ev) return; const pos = pointerPos(ev);
      const tool = state.activeTool;
      if(['rect','ellipse','line'].includes(tool)){
        finalizeShape(layerObj, start, pos, tool);
      }
      snapshot(layerObj);
      if(typeof e.preventDefault === 'function') e.preventDefault();
    }

    // generic helpers
    function drawStroke(layerObj, from, to){
      const ctx = layerObj.ctx;
      ctx.save();
      ctx.globalCompositeOperation = (state.activeTool==='eraser')? 'destination-out' : 'source-over';
      ctx.globalAlpha = state.opacity;
      ctx.strokeStyle = state.color; ctx.fillStyle = state.color;
      ctx.lineWidth = state.size;
      ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(to.x, to.y); ctx.stroke(); ctx.closePath();
      // small dot to make single clicks
      ctx.beginPath(); ctx.arc(to.x, to.y, Math.max(1,state.size/2), 0, Math.PI*2); ctx.fill(); ctx.closePath();
      ctx.restore();
    }

    function drawPreviewShape(layerObj, a, b, tool){
      // we will paint directly on top temporarily by redrawing previous snapshot then painting shape
      const l = layerObj;
      // restore latest snapshot to clear previous preview
      if(l.history && l.historyIndex>=0){ l.ctx.putImageData(l.history[l.historyIndex],0,0); }
      l.ctx.save(); l.ctx.globalAlpha = state.opacity; l.ctx.strokeStyle = state.color; l.ctx.lineWidth = state.size; l.ctx.fillStyle = state.color;
      const x = Math.min(a.x,b.x), y = Math.min(a.y,b.y), w = Math.abs(a.x-b.x), h = Math.abs(a.y-b.y);
      if(tool==='rect'){ l.ctx.strokeRect(x,y,w,h); }
      else if(tool==='ellipse'){ l.ctx.beginPath(); l.ctx.ellipse(x+w/2,y+h/2,w/2,h/2,0,0,Math.PI*2); l.ctx.stroke(); }
      else if(tool==='line'){ l.ctx.beginPath(); l.ctx.moveTo(a.x,a.y); l.ctx.lineTo(b.x,b.y); l.ctx.stroke(); }
      l.ctx.restore();
    }

    function finalizeShape(layerObj,a,b,tool){ drawPreviewShape(layerObj,a,b,tool); }

    function getPointerEvent(e){
      // prefer touches if present (touchstart/touchmove), then changedTouches (touchend), else mouse event
      if(!e) return null;
      if(e.touches && e.touches.length) return e.touches[0];
      if(e.changedTouches && e.changedTouches.length) return e.changedTouches[0];
      return e;
    }

    function attach(name, fn){ canvasEl.addEventListener(name, fn, {passive:false}); }
    // mouse events
    attach('mousedown', begin); attach('mousemove', move); attach('mouseup', up);
    // touch events: pass the original TouchEvent (not individual Touch) so we can call preventDefault on it
    attach('touchstart', begin); attach('touchmove', move); attach('touchend', up);

  }

  // simple flood fill implementation (stack-based)
  function floodFill(layerObj, x, y, targetColor){
    const ctx = layerObj.ctx; const w = layerObj.canvas.width, h = layerObj.canvas.height;
    const img = ctx.getImageData(0,0,w,h);
    const data = img.data; const idx = (y*w + x)*4;
    const baseR = data[idx], baseG = data[idx+1], baseB = data[idx+2], baseA = data[idx+3];
    const tr = targetColor[0], tg = targetColor[1], tb = targetColor[2], ta = targetColor[3];
    if(baseR===tr && baseG===tg && baseB===tb && baseA===ta) return;
    const stack = [[x,y]];
    while(stack.length){ const [cx,cy] = stack.pop(); if(cx<0||cy<0||cx>=w||cy>=h) continue;
      const i = (cy*w + cx)*4; if(data[i]===tr && data[i+1]===tg && data[i+2]===tb && data[i+3]===ta) continue; if(data[i]===baseR && data[i+1]===baseG && data[i+2]===baseB && data[i+3]===baseA){ data[i]=tr; data[i+1]=tg; data[i+2]=tb; data[i+3]=ta; stack.push([cx+1,cy]); stack.push([cx-1,cy]); stack.push([cx,cy+1]); stack.push([cx,cy-1]); }
    }
    ctx.putImageData(img,0,0);
  }

  // utility color conversions
  function hexToRgba(hex, a=255){ hex = hex.replace('#',''); if(hex.length===3) hex = hex.split('').map(x=>x+x).join(''); const r=parseInt(hex.slice(0,2),16), g=parseInt(hex.slice(2,4),16), b=parseInt(hex.slice(4,6),16); return [r,g,b,a]; }
  function rgbaToHex(r,g,b,a){ return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join(''); }

  // simple resize watcher
  window.addEventListener('resize', ()=>{ resizeAll(); });

  // initialize UI inputs
  colorInput.addEventListener('change', (e)=>{ state.color = e.target.value; updateFromInputs(); });
  sizeRange.addEventListener('input', (e)=>{ state.size = parseInt(e.target.value,10); updateToolOptions(); updateFromInputs(); });
  opacityRange.addEventListener('input', (e)=>{ state.opacity = parseInt(e.target.value,10)/100; });

  // init
  createLayer('Background'); createLayer('Layer'); resizeZ(); updateToolOptions();

  function resizeZ(){ // reorder z-index to match layers array
    layers.forEach((l,i)=>{ l.canvas.style.zIndex = i; l.canvas.width = canvasContainer.clientWidth; l.canvas.height = canvasContainer.clientHeight; });
  }

})();
</script>
</body>
</html>
